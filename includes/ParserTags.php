<?php
if (!defined('MEDIAWIKI'))
	die("MediaWiki extensions cannot be run directly.");
if (!defined('WikiDB')) {
	die("The WikiDB extension has not been set up correctly.<br>'"
		. basename(__FILE__) . "' should not be included directly.<br>Instead, "
		. "add the following to LocalSettings.php: "
		. "<tt><b>include_once(\"WikiDB/WikiDB.php\");</b></tt>");
}
/**
 * Functions to handle the new parser tags implemented by WikiDB.
 *
 * @author Mark Clements <mclements at kennel17 dot co dot uk>
 * @copyright Copyright Â© 2006-2024, Mark Clements
 * @license http://creativecommons.org/licenses/by-sa/2.0/uk/ CC BY-SA 2.0 UK
 * @version $Rev: 2439 $
 */

// efWikiDB_GuessTypes() - Handler for the <guesstypes> tag.
//
// Purpose:
// 	This tag is mainly for testing purposes.  It allows you to provide wiki-based
//  input and see which type WikiDB will treat it as, if the field is otherwise
//  untyped.  Primarily for use by people creating their own data types for use
//  within WikiDB.
//
// Arguments:
//	None.
//
// Tag contents:
// 	A valid line is any line with a colon.  The text before the colon is a
//  description which is displayed in the first column of the resulting table
//  (useful when there are multiple tests within the same tag) and the text after it
//  is the string to be parsed.  Multiple colons are allowed - the two components
//  are split on the first colon, and subsequent occurrence of a colon are part of
//  the text to be parsed (so the description may not contain a colon.
//  Non-valid lines are ignored, and not output at all.
//
// Output:
//	A table with one row per valid line, with the following columns: Description,
//  Original value unrendered, original value rendered, type, typed value
//  unrendered, typed value rendered.
//	* Description - as entered on the page.
//	* Original value - as entered on the page.
//	* Type - the name of the type, as guessed by WikiDB.
//	* Typed value - the result of formatting the original value as if it was the
//    guessed type.
//  For the 'Original Value' and 'Typed Value', there are two columns output:
//	* Unrendered - the literal wikitext, unparsed.
//	* Rendered - the rendered output, as it would appear in the page.
	function efWikiDB_GuessTypes($Input, $Args, $Parser, $Frame) {
	// If the page is being parsed for a save operation, then do nothing.
		if (WikiDB::IsParsingForSave())
			return "";

		$FormattedLines = WikiDB_Parser::ParseGuessTypesTag($Input);
		$Output = WikiDB_HTMLRenderer::FormatGuessTypesOutput($FormattedLines,
															  $Parser, $Frame);

		return $Output;
	}

// efWikiDB_DataTag() - Handler for the <data> tag.
//
// Purpose:
//	To define rows of data belonging to the specified table.
//
// Arguments:
//	table:
//		The name of the table the data should be added to. Required.
//	template:
//		The name of a template that the data should be passed to for display.
//		Additionally, "none" (the default value) may be used to suppress all output,
//		and "default" may be used to display the data in the default WikiDB style.
//
// Tag contents:
//	See WikiDB_Parser::ParseDataTag().
//
// Output:
//	Nothing if no template argument is supplied, or template="none".
//	A table showing the data in the standard WikiDB format if template="default".
//	The output generated by the specified template (with the fields passed as
//  template parameters) if neither of the above.
	function efWikiDB_DataTag($Input, $Args, $Parser, $Frame) {
	// Get the Title object for the item being parsed.
		$Title = WikiDB_GetTitleFromParser($Parser);

	// This tag has no effect in the MediaWiki namespace, so return the contents
	// unmodified.  $Input just contains the tag contents, so we need to
	// re-wrap it in the <data> tag, including the supplied arguments, in order to
	// undo the effects of the tag.
	// Note that I haven't used htmlspecialchars() here, because I believe this
	// will be done automatically by MW before the result is output, and it shouldn't
	// happen twice.
	// TODO: The above comment contradicts the code, which *is* performing escaping.
	//		 Check whether or not escaping is required and update the code or the
	//		 comment, as appropriate.
		if ($Title->getNamespace() == NS_MEDIAWIKI) {
			$Output = "<data";
			foreach ($Args as $ArgName => $ArgValue) {
				$Output .= ' ' . WikiDB_EscapeHTML($ArgName, ENT_QUOTES)
						 . '="' . WikiDB_EscapeHTML($ArgValue, ENT_QUOTES) . '"';
			}
			$Output .= ">" . $Input . "</data>";
			return $Output;
		}

	// Replace any template variables in argument values.
		$Args = pWikiDB_ReplaceVariablesInArgs($Args, $Parser, $Frame);

	// Normalise the tag arguments so that all variables are set
	// and appropriate defaults are filled in where necessary.
		$Args = pWikiDB_DataTag_NormaliseArgs($Args, $Title);

	// Check for a missing table argument.
		if ($Args['table'] == "") {
		// If we are in a table namespace, then it defaults to the current table.
			if (WikiDB_IsValidTable($Title)) {
				$Args['table'] = $Title->getFullText();
			}
		// Otherwise the data is unusable, so we print a warning and exit.
			else {
				$Msg = "''"
					 . WikiDB_Msg('wikidb-missing-tablename', "&lt;data&gt;")
					 . "''";
				return WikiDB_Parse($Msg, $Parser, $Frame);
			}
		}

	// If this is being transcluded, then skip the tag if expand_when is set
	// to 'direct'.
		if ($Frame->isTemplate() && $Args['expand_when'] == "direct")
			return "";

	// If this is not being transcluded, then skip the tag if expand_when is
	// set to 'transcluded'.
		if (!$Frame->isTemplate() && $Args['expand_when'] == "transcluded")
			return "";

	// We need to expand any template variables that may be present in the
	// input, which is particularly important when the <data> tag is being
	// transcluded, but we do it in all cases (including when not being
	// transcluded).
	// Note that this expands template variables (using triple-braces) and
	// also expands any sub-templates (using double-braces).
		$Input = $Parser->replaceVariables($Input, $Frame);

	// Add the tag details to the array of extracted tags, so that calling code can
	// use this for other purposes (e.g. saving to the database, or summarising on
	// the edit page).
		WikiDB_Parser::RegisterMatchedTag($Parser, $Title, 'data', $Args, $Input);

	// If the page is being parsed for a save operation, no need to do the rest of
	// the work to actually render the data.  We simply return.
		if (WikiDB::IsParsingForSave()) {
			return "";
		}

	// If the template is "none", then the data is not displayed, so we return an
	// empty string.
		if ($Args['template'] == "none")
			return "";

	// Parse the tag contents using the standard WikiDB data parsing algorithm.
		$Table = new WikiDB_Table($Args['table']);
		$Data = WikiDB_Parser::ParseDataTag(
											$Input,
											$Args['fields'],
											$Args['separator']
										);

	// Create a results object from the data, which is what our rendering functions
	// require.
		$objResult = WikiDB_QueryResult::NewFromDataArray($Table, $Data, $Title);

	// If using the 'default' template, output the data in the standard way.
		if ($Args['template'] == "default") {
			$Output = WikiDB_HTMLRenderer::FormatTableData($objResult);
		}
	// Otherwise, call the appropriate template with each field as a named parameter.
		else {
			$Output = WikiDB_HTMLRenderer::TemplateFormatTableData($objResult,
																   $Args['template'],
																   $Args['thead'],
																   $Args['tfoot']);
		}

		return WikiDB_Parse($Output, $Parser, $Frame);
	}

// efWikiDB_RepeatTag() - Handler for the <repeat> tag.
//
// Purpose:
//	To output data from a table in the specified format.
//	THIS TAG IS CURRENTLY VERY EXPERIMENTAL, AND LIKELY TO CHANGE DRASTICALLY!
//
// Arguments:
//	table:
//		The name of the table to pull the data from.
//	sort:
//		Sort criteria (optional).  Uses default (undefined) sort order if omitted.
//	criteria:
//		Filter criteria (optional).  Defaults to all records if omitted.
//
// Tag contents:
//	May be left blank.  If not then the contents are repeated for each row of the
//	resulting data-set, with variables expanded in a similar way to template
//  parameters.
//
// Output:
//	If the tag has no contents then the resulting data-set is output in the standard
//  WikiDB format.  Otherwise the contents are repeated for each row of data, with
//  variables expanded.
	function efWikiDB_RepeatTag($Input, $Args, $Parser, $Frame) {
	// If the page is being parsed for a save operation, then do nothing.
		if (WikiDB::IsParsingForSave())
			return "";

	// Repeat tags change all the time, so disable caching.
		WikiDB_DisableCache($Parser);

	// Replace any template variables in argument values.
		$Args = pWikiDB_ReplaceVariablesInArgs($Args, $Parser, $Frame);

	// Get table argument (required)
		$TableName = isset($Args['table']) ? $Args['table'] : "";
		if ($TableName == "") {
			$Msg = "''" . WikiDB_Msg('wikidb-missing-tablename', "&lt;repeat&gt;") . "''";
			return WikiDB_Parse($Msg, $Parser, $Frame);
		}

	// Get sort argument (optional)
		$Sort = isset($Args['order']) ? $Args['order'] : (isset($Args['sort']) ? $Args['sort'] : "");

	// Get criteria argument (optional)
		$Where = isset($Args['criteria']) ? $Args['criteria'] : "";

	// Get col argument (optional)
		$Cols = array();
		if (isset($Args['col']) && trim($Args['col']) !== "") {
		// Split by comma, trim whitespace, and normalise case
			$Cols = array_map('trim', explode(',', $Args['col']));
		}

	// Perform the query and get the resulting data set.
		$Query = new WikiDB_Query($TableName, $Where, $Sort);

	// If an error occurred, output the error.
		if ($Query->HasErrors()) {
			return $Query->GetErrorMessage();
		}

		$objResult = $Query->GetRows();

	// If tag contents are empty, display in the standard format, but filtered by $Cols if set.
		if (trim($Input) == "") {
			$Output = WikiDB_HTMLRenderer::FormatTableData($objResult, true, $Cols, false); // <--- false here
		}
	// If tag contents are non-empty then use it as a template for each row
	// of the returned data, expanding variables where necessary.
		else {
			$arrInput = WikiDB_Parser::ParseQueryTag($Input);
			$Output = WikiDB_HTMLRenderer::CustomFormatTableData(
												$objResult, $Parser, $Frame,
												$arrInput['body'], $arrInput['header'],
												$arrInput['footer'], $Cols
											);
		}

	// Return the resulting output, parsed as wiki text.
		return WikiDB_Parse($Output, $Parser, $Frame);
	}

// pWikiDB_DataTag_NormaliseArgs()
// Takes an array containing the arguments which may be supplied to a <data> tag
// and normalises them to ensure that (a) all args are present (b) sensible defaults
// are used and (c) any arguments which may have more than one representation are
// normalised to a standard form (e.g. all case-insensitive args become lower-case).
	function pWikiDB_DataTag_NormaliseArgs($Args, $Title) {
	// If the argument list is not an array, then it is completely invalid, so
	// we replace it with an empty array which will allow the defaults to be
	// filled in correctly by the subsequent code.
		if (!is_array($Args))
			$Args = array();

	//////////////////////////////////////////////////
	// 'table' - the table that the data belongs in.
	// Required, default = "" (no table specified)

		if (!isset($Args['table']))
			$Args['table'] = "";
		else
			$Args['table'] = trim($Args['table']);

	//////////////////////////////////////////////////
	// 'thead'/'tfoot' - templates to use just once before/after the data rows.
	// If the 'template' attribute is one of the built-in defaults, or 'fields' is
	// not set, then this will be ignored (we fill it in here, but reset it to "" if
	// any of these conditions are met, which is why these arguments are checked
	// first).

		if (!isset($Args['thead']))
			$Args['thead'] = "";
		else
			$Args['thead'] = trim($Args['thead']);

		if (!isset($Args['tfoot']))
			$Args['tfoot'] = "";
		else
			$Args['tfoot'] = trim($Args['tfoot']);

	//////////////////////////////////////////////////
	// 'template' - the template used to display the data.
	// Possible values are 'none' (not displayed), 'default' (displayed in the
	// standard built-in format) or else the name of a template to use.  This
	// template will be passed all the field values by name, and will be included
	// once for each row of data within the tag.
	// Optional, default = "none"

	// If not present, set to default value.
		if (!isset($Args['template']))
			$Args['template'] = "none";
	// Otherwise, trim any leading/trailing whitespace from the name
		else
			$Args['template'] = trim($Args['template']);

	// Normalise the two special internal values, which are
	// case-insensitive.  If either of these two values are used, then we also
	// remove any thead/tfoot settings as these should not be used in those
	// instances.
		switch (strtolower($Args['template'])) {
			case "none":
			case "default":
				$Args['template'] = strtolower($Args['template']);
				$Args['thead'] = "";
				$Args['tfoot'] = "";
				break;
		}

	//////////////////////////////////////////////////
	// 'fields' - A list of field names indicating the columns being defined by this
	// data tag.  If this argument is present then we are in multi-row mode, meaning
	// that each row of the <data> tag is a row of data, with fields separated by
	// the specified separator string (or "," if none specified).  The fields in each
	// row contain data for the fields named in this list.  If a row has too many
	// fields, later ones are discarded.  If it has too few they are set to "" (empty
	// string).
	// In single-row mode, no 'fields' argument is used, and instead each row is
	// a "name=value" pair.

	// If the 'fields' argument is not present, set it to null. We use null rather
	// than "" because we need to distinguish between 'not present' and 'present but
	// empty'.  The former means we are in single-row mode, the latter means we are
	// in multi-row mode but no fields were specified.
		if (!isset($Args['fields'])) {
			$Args['fields'] = null;
		// In single-row mode, there is no need for header/footer templates as there
		// is only one row.
		// TODO: Actually, it might be useful to allow this, even though it's not
		// 		 needed, for example so that you can use the same template for the
		//		 body in multi/single-row modes and still wrap it in the appropriate
		// 		 header/footer - though note that this can still be achieved using
		// 		 standard in-line template tags before/after the <data> tag, which
		//		 might be better-practice.
			$Args['thead'] = "";
			$Args['tfoot'] = "";
		}

	//////////////////////////////////////////////////
	// 'separator' - the character string used to separate field values when
	// in multi-row mode.  This is only relevant if 'fields' is filled in, but
	// we make sure it is filled in and valid in all cases.
	// Optional, default = ","

	// If not present, or blank, set to default value.  Note that we don't
	// trim() the setting, as space could be a valid separator.
	// TODO: Newline cannot be used, so perhaps we should remove them.  That
	// 		 said, it may make more sense not to 'fix' the string in this way, as the
	// 		 fix may create unwanted behaviour and it is unlikely that a newline
	//		 will be inserted accidentally inside a quoted attribute.
		if (!isset($Args['separator']) || $Args['separator'] == "")
			$Args['separator'] = ",";

	//////////////////////////////////////////////////
	// expand_when
	// An argument that describes when the <data> tag should be used for populating
	// the database.  It may have one of the following values:
	// * "direct":		The tag will only be used on the page where it is
	//					specifically defined.  It will not be expanded when the page
	//					is transcluded.
	// * "transcluded":	The tag will only be used when the page is transcluded.
	//					It will not be expanded on the page itself.
	// * "always":		The tag will always be expanded.
	// If the argument is invalid or missing, then the default value is "transcluded"
	// for pages within the template namespace, and "always" for pages in any
	// other namespace.

	// Get the expand_when argument from the array, if present.
		$ExpandWhen = "";
		if (isset($Args['expand_when']))
			$ExpandWhen = $Args['expand_when'];

	// Normalise, by trimming white-space and forcing to lower-case.
		$ExpandWhen = strtolower(trim($ExpandWhen));

	// If it is not in the array of allowed values, set it to an empty string.
	// Invalid values are treated the same as if the argument was not present
	// at all.
		if (!in_array($ExpandWhen, array("direct", "transcluded", "always")))
			$ExpandWhen = "";

	// If the argument is blank or invalid, set the default value depending on the
	// namespace.
		if (IsBlank($ExpandWhen)) {
			if ($Title->getNamespace() == NS_TEMPLATE)
				$ExpandWhen = "transcluded";
			else
				$ExpandWhen = "always";
		}

	// Add the normalised value back into the $Args array.
		$Args['expand_when'] = $ExpandWhen;

	//////////////////////////////////////////////////

	// Return the normalised set of arguments.
		return $Args;
	}

	function pWikiDB_ReplaceVariablesInArgs($Args, $Parser, $Frame) {
	// Replace any variables in argument names.
		foreach ($Args as $ArgName => $ArgValue) {
			$Args[$ArgName] = $Parser->replaceVariables($ArgValue, $Frame);
		}

		return $Args;
	}
